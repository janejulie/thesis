\chapter{Informatische Grundlagen}
\label{sec:grundlagen:info}
Um das Problem der Trainingsplanung zu lösen, wird Constraint Programmierung verwendet. Dieser Programmierstil ist deklarativ und ein Teilbereich der künstlichen Intelligenz.

\section{Constraint Programmierung}
Dieses Programmierparadigma entstand als Erweiterung der logischen Programmierung um Constraints (= Randbedingungen). Ohne eine konkrete Lösungsstrategie algorithmisch angeben zu müssen, kann nach einer Lösung des beschriebenen Problems gesucht werden. Dafür wird das Problem in Variablen und Constraints formalisiert. Die Variablen halten Informationen über das Problem fest. Ihre Eigenschaften und Beziehungen zwischen ihnen werden durch die Constraints beschrieben. Eine Lösungsinstanz ist eine Belegung der Variablen mit Werten aus dem Wertebereich, sodass die definierten Constraints erfüllt sind. \cite{EssentialsConstraintProgrammierung, HandbookConstraintProgramming}

\subsection{Variablen}
Constraint Programmierung baut auf einer Menge von Variablen auf. Zu jeder unbekannten Größe im System werden eine Variable und ihr zugehöriger Wertebereich definiert. Das können boolsche, numerische und reelle Variablen sein.
Für die Erstellung des Trainingsplan reicht die Betrachtung der Constraint Integer Programmierung. Dabei handelt es sich um die Schnittmenge von Constraint Programmierung und Integer Linear Programmierung. Die wesentliche Einschränkung betrifft die Wertebereiche der Variablen. Für die Belegung der Variablen kommen dann nur ganzzahlige numerische Werte mit endlichem Wertebereich in Frage. %Eine Modellierung mit diesen nennt man auch Finite-Domain Constraint-System {Finite-Domain-Constraint-System?}. 
Es gibt unterschiedliche Arten der Definition des Wertebereichs. Für Intervalle werden gebundene Wertebereiche verwendet, die über den kleinsten und größten Wert definiert werden, deshalb aber keine Werte im Intervall ausschließen können. Im Gegensatz dazu sind ungebundene Wertebereiche eine Menge der möglichen Werte. Diese Repräsentation ist jedoch speicherlastiger. Abzuwägen ist, ob eine präzisere Bestimmung des Wertebereichs den Suchraum verkleinert, sodass die Problemlösung performanter ist.
Wahrheitswerte können durch ungebundene Variablen als $variable \in \{0, 1\}$ abgebildet werden. Es lässt sich damit auch eine Liste von Begriffen abbilden, in der diese festen Zahlen zugeordnet werden. \cite{HandbookKnowledgeRepresentation}

\subsection{Constraints}
Die namensgebenden Constraints halten die Bedingungen fest, die in der Lösungsinstanz erfüllt sein müssen. Sie beschreiben Zusammenhänge und Beziehungen der Variablen in prädikatenlogischen Aussagen. Zusammenhänge können arithmetischer Natur $ +, -, \le, \ge, +, -, * , \%, sum$ oder logische Operatoren $\Rightarrow, \Leftrightarrow, \wedge, \vee$ sein.
Für diese Modellierung sind die vorangegangenen Constraints relevant. Im Global Constraint Katalog \cite{GlobalConstraintWeb} ist eine umfassende Auflistung der Constraints verfügbar. 
\subsection{Lösungssuche}

Zu jedem Constraint gehört ein Propagierer, der den Wertebereich der Variablen filtert. Im Allgemeinen erfolgt die Lösung des Problems rekursiv. Das Verfahren ist zweistufig: Im ersten Schritt wird nach aktuellen Annahmen die Propagation des Suchraums für jeden Constraint gestartet. Erreichen die Propagierer ihren Fixpunkt und können die Wertebereiche nicht weiter eingrenzen, folgt im nächsten Schritt die systematische Suche nach einer Lösung auf dem neuen Suchraum. Eine weitere Annahme über die Belegung einer Variable wird getroffen und der Suchprozess rekursiv aufgerufen. Dieser Vorgang wiederholt sich, bis alle Variablen vollständig belegt sind. Ist in einem Schritt die Erfüllung der Constraints \textit{infeasible} (=widersprüchlich), erfolgt ein Backtracking, das die letzte Annahme ausschließt. Im Lösungsprozess ist die Suchstrategie von zentraler Bedeutung, um ein anwendbares Programm zu erhalten. Die Reihenfolge der Belegung der Variablen und die gewählten Werte aus dem Wertebereich können die Laufzeit stark beeinflussen. \newline 
 Definiert man das Problem in der oben genannten Struktur, ist die Menge der Variablen und Constraints ein sogenanntes Constraint Satisfaction Problem (CSP). Diese zielen im Lösungsprozess auf den Beweis der Existenz einer Lösung und das Finden einer Lösungsinstanz ab. Es können mehrere lösende Belegungen existieren. Gegebenenfalls ist aber auch keine Lösung für das Constraint-System möglich. Das ist bei widersprüchlichen Constraints der Fall. 

\subsubsection{Optimierung}
Für Probleme mit einer Menge an erfüllenden Lösungsinstanzen wird die Optimierung der Lösungen interessant. Dafür legt man die Entscheidungsvariable und ihre Optimierungsrichtung fest. 
Modelliert man ein Optimierungsproblem mit Constraint Programmierung, dann erweitert sich der rekursive Lösungsprozess häufig zu einem Branch-and-Bound-Algorithmus. Dann wird die Entscheidungsvariable bei jeder gefundenen Lösungsinstanz abgelegt. Neue Lösungen müssen je nach Optimierungsrichtung den Wert übertreffen oder unterschreiten.