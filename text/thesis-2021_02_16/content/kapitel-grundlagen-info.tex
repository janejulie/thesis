\chapter{Informatische Grundlagen}
\label{sec:grundlagen:info}
Um das Problem der Trainingsplanung zu lösen wird Constraint Programmierung verwendet. Dieser Programmierstil ist deklarativ und ein Teilbereich der künstlichen Intelligenz.

\section{Constraint Programmierung}
Dieses Programmierparadigma entstand als Erweiterung der logischen Programmierung um Constaints (= Randbedingungen). Ohne eine konkrete Lösungsstrategie algorithmisch angeben zu müssen, kann nach einer Lösung des beschriebenen Problems gesucht werden. Dafür wird das Problem in Variablen und Constraints formalisiert. Die Variablen halten Informationen über das Problem fest. Ihre Eigenschaften und Beziehungen zwischen ihnen werden durch die Constraints beschrieben. Eine Lösungsinstanz ist eine Belegung der Variablen, so dass die definierten Constraints erfüllt sind. \cite{EssentialsConstraintProgrammierung, HandbookConstraintProgramming}

\subsection{Variablen}
Constraint Programmierung baut auf einer Menge von Variablen auf. Zu jeder unbekannten Größe im System wird eine Variable und ihr zugehöriger Wertebereich definiert. Das können boolsche, numerische und reelle Variablen sein.
Für die Erstellung des Trainingsplan reicht die Betrachtung der Constraint Integer Programmierung. Dabei handelt es sich um die Schnittmenge von Constraint Programmierung und Integer Linear Programmierung. Die wesentliche Einschränkung betrifft die Wertebereiche der Variablen. Für die Belegung der Variablen kommen dann nur ganzzahlige numerische Werte mit endlichem Wertebereich in Frage. Eine Modellierung mit diesen nennt man auch Finite-Domain Constraint-System. Es gibt unterschiedliche Arten der Definition des Wertebereichs. Für Intervalle werden gebundene Wertebereiche verwendet, die über den kleinsten und größten Wert definiert werden, deshalb aber keine Werte im Intervall ausschließen können. Im Gegensatz dazu sind ungebundene Wertebereiche eine Menge der möglichen Werte. Diese Repräsentation ist jedoch speicherlastiger. Abzuwägen ist, ob eine präzisere Bestimmung des Wertebereichs den Suchraum verkleinert, sodass die Problemlösung performanter ist. \newline
Wahrheitswerte können durch ungebundene Variablen als $variable \in \{0, 1\}$ abgebildet werden. Es lässt sich damit auch eine Liste von Begriffen abbilden, in der diese festen Zahlen zugeordnet werden. \cite{HandbookKnowledgeRepresentation}

\subsection{Constraints}
Die namensgebenden Constraints halten die Bedingungen fest, die in der Lösungsinstanz erfüllt sein müssen. Sie beschreiben Zusammenhänge und Beziehungen der Variablen in prädikatenlogischen Aussagen.\newline
Zusammenhänge können arithmetischer Natur sein $ +, -, \le, \ge, +, -, * , \%, sum$ oder logische Operatoren sein $\Rightarrow, \Leftrightarrow, \wedge, \vee $.
Für diese Modellierung sind die vorangegangenen Constraints relevant. Im Global Constraint Katalog \cite{GlobalConstraintWeb} ist eine umfassende Auflistung der Constraints verfügbar. 
\subsection{Lösungssuche}
Zu jedem Constraint gehört ein Propagierer, der den Wertebereich der Variablen filtert. Im Allgemeinen erfolgt die Lösung des Problems rekursiv. Das Verfahren ist zweistufig. Im ersten Schritt wird nach aktuellen Annahmen die Propagation des Suchraums für jeden Constraint gestartet. Erreichen die Propagierer ihren Fixpunkt und können die Wertebereiche nicht weiter eingrenzen, folgt im nächsten Schritt die systematische Suche nach einer Lösung auf dem neuen Suchraum. Eine weitere Annahme über die Belegung einer Variable wird getroffen und der Suchprozess rekursiv aufgerufen. Dieser Vorgang wiederholt sich bis alle Variablen vollständig belegt sind. Ist in einem Schritt die Erfüllung der Constraints \textit{infeasible} (=widersprüchlich) erfolgt ein Backtracking, das die letzte Annahme ausschließt.
Definiert man das Problem in der oben genannten Struktur, ist die Menge der Variablen und Constraints ein sogenanntes Constraint Satisfaction Problem (CSP). Diese zielen im Lösungsprozess auf den Beweis der Existenz einer Lösung und das Finden einer Lösungsinstanz ab. Es können mehrere lösende Belegungen existieren. Gegebenenfalls ist aber auch keine Lösung für das Constraint-System möglich. Das ist bei widersprüchlichen Constraints der Fall. 

\subsubsection{Optimierung}
Für Probleme mit einer Menge an erfüllenden Lösungsinstanzen wird die Optimierung der Lösungen interessant. Dafür legt man die Entscheidungsvariable und ihre Optimierungsrichtung fest. 
Modelliert man ein Optimierungsproblem mit Constraint Programmierung, dann erweitert sich der rekursive Lösungsprozess häufig zu einem Branch-and-Bound Algorithmus. Dann wird die Entscheidungsvariable bei jeder gefundenen Lösungsinstanz abgelegt. Neue Lösungen müssen diese je nach Optimierungsrichtung übertreffen oder unterschreiten.
Weitere Möglichkeiten sind lokale Suche oder ausschließlich Backtracking.


% Da die Trainingsplanerstellung als Constraint-Satisfaction Problem modelliert wird, gibt dieses Kapitel einen Einblick in die Grundlagen dieser Technik.

% Unterschied zwischen Variablen und Konstanten

% Um eine Lösung zu finden, die alle Constraints erfüllt kommt ein Solver zum Einsatz. Das Lösen des Problems wird auch Modelling genannt. \TODO{Ist das Modellierung oder Solution?}

% Eine Lösungsinstanz ist eine Belegung der Variablen mit Werten aus dem Wertebereich so, dass die Constraints erfüllt sind. 

% Hier kommen die Propagierer zu den Constraints zum Einsatz.

% Im Lösungsprozess ist die Suchstrategie von zentraler Bedeutung um ein anwendbares Programm zu erhalten. Die Reihenfolge der Belegung der Variablen und die gewählten Werte können die Laufzeit stark beeinflussen. In den meisten Fällen wird hier auf ein Branch and Bound Algorithmus zurückgegriffen. 
